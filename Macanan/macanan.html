<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Permainan Macanan</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="container">
      <canvas id="gameCanvas" width="1000" height="500"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let uwongInHand = 21;
      let uwongOnBoard = 0;
      let macanInHand = 1;
      let turn = 1; // 1 uwong, 2 macan
      let entities = {};

      const points = [
        { x: 150, y: 50 },
        { x: 250, y: 50 },
        { x: 350, y: 50 },
        { x: 450, y: 50 },
        { x: 550, y: 50 },
        { x: 150, y: 150 },
        { x: 250, y: 150 },
        { x: 350, y: 150 },
        { x: 450, y: 150 },
        { x: 550, y: 150 },
        { x: 150, y: 250 },
        { x: 250, y: 250 },
        { x: 350, y: 250 },
        { x: 450, y: 250 },
        { x: 550, y: 250 },
        { x: 150, y: 350 },
        { x: 250, y: 350 },
        { x: 350, y: 350 },
        { x: 450, y: 350 },
        { x: 550, y: 350 },
        { x: 150, y: 450 },
        { x: 250, y: 450 },
        { x: 350, y: 450 },
        { x: 450, y: 450 },
        { x: 550, y: 450 },
        { x: 75, y: 200 },
        { x: 75, y: 250 },
        { x: 75, y: 300 },
        { x: 0, y: 150 },
        { x: 0, y: 250 },
        { x: 0, y: 350 },
        { x: 625, y: 200 },
        { x: 625, y: 250 },
        { x: 625, y: 300 },
        { x: 700, y: 150 },
        { x: 700, y: 250 },
        { x: 700, y: 350 },
      ];

      const connections = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
        [5, 6],
        [6, 7],
        [7, 8],
        [8, 9],
        [10, 11],
        [11, 12],
        [12, 13],
        [13, 14],
        [15, 16],
        [16, 17],
        [17, 18],
        [18, 19],
        [20, 21],
        [21, 22],
        [22, 23],
        [23, 24],
        [0, 5],
        [5, 10],
        [10, 15],
        [15, 20],
        [1, 6],
        [6, 11],
        [11, 16],
        [16, 21],
        [2, 7],
        [7, 12],
        [12, 17],
        [17, 22],
        [3, 8],
        [8, 13],
        [13, 18],
        [18, 23],
        [4, 9],
        [9, 14],
        [14, 19],
        [19, 24],
        [0, 6],
        [6, 12],
        [12, 18],
        [18, 24],
        [16, 20],
        [12, 16],
        [8, 12],
        [4, 8],
        [2, 6],
        [2, 8],
        [6, 10],
        [8, 14],
        [10, 16],
        [14, 18],
        [16, 22],
        [18, 22],
        [10, 25],
        [10, 26],
        [10, 27],
        [25, 28],
        [26, 29],
        [27, 30],
        [25, 26],
        [26, 27],
        [28, 29],
        [29, 30],
        [14, 31],
        [14, 32],
        [14, 33],
        [31, 34],
        [32, 35],
        [33, 36],
        [31, 32],
        [32, 33],
        [34, 35],
        [35, 36],
      ];

      function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;

        connections.forEach(([start, end]) => {
          const pointA = points[start];
          const pointB = points[end];
          ctx.beginPath();
          ctx.moveTo(pointA.x, pointA.y);
          ctx.lineTo(pointB.x, pointB.y);
          ctx.stroke();
        });

        points.forEach((point, index) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
          ctx.fillStyle = "black";
          ctx.fill();
        });

        for (let index in entities) {
          const entity = entities[index];
          ctx.beginPath();
          ctx.arc(points[index].x, points[index].y, 10, 0, Math.PI * 2);
          ctx.fillStyle = entity === "macan" ? "red" : "blue";
          ctx.fill();
        }
      }

      function placeEntity(index) {
        // if (uwongInHand === 21 && turn == 1) {
        //   placeUwongBlock(index);
        //   console.log(index);
        // } else if (!(index in entities)) {
        //   if (macanInHand > 0 && turn == 2) {
        //     entities[index] = "macan";
        //     macanInHand--;
        //     turn = 1;
        //   } else if (uwongInHand > 0 && turn == 1) {
        //     entities[index] = "uwong";
        //     uwongInHand--;
        //     uwongOnBoard++;
        //     turn = 2;
        //   } else if (uwongInHand == 0 && turn == 1) {
        //     // Cek apakah ada uwong yang bisa dipindahkan
        //     moveUwong(index);
        //   } else if (macanInHand == 0 && turn == 2) {
        //     // Cek apakah macan bisa dipindahkan
        //     moveMacan(index);
        //   }
        //   drawBoard();
        // }
        if (!(index in entities)) {
          if (turn == 1 && uwongInHand > 0) {
            entities[index] = "uwong";
            uwongInHand--;
            uwongOnBoard++;
            turn = 2;
          } else if (turn === 2 && macanInHand > 0) {
            entities [index] = "macan";
            macanInHand--;
            turn = 1;
          }
          drawBoard();
        } else if (entities[index] === (turn === 1 ? "uwong" : "macan")) {
          moveEntity(index);
        }
      }

      function moveEntity(index) {
        const validMoves = connections.filter(([a, b]) => a == index || b == index);
        const availableMoves = validMoves.map(([a, b]) => (a === index ? b : a)).filter((next) => !(next in entities));

        if (turn === 2) {
          //aturan macan loncat
          const jumps = connections.filter(([a, b]) => {
            const mid = a === index ? b : a;
            const target = a === mid ? b : a;

            // cek posisi ada uwong dan posisi target kosong
            return (
              (a == index || b == index) &&
              mid in entities && 
              entities [mid] == "uwong" &&
              !(target in entities) &&
              Math.abs(mid - index) % 2 === 1 
            )
          })

          if (jumps.length > 0) {
            const [a, b] = jumps[0];
            const mid = a === index ? b : a;
            const target = a === mid ? b : a;

            //eksekusi
            delete entities[index];
            delete entities[mid]; //removed uwong yang dilompati
            uwongOnBoard--;
            entities[target] = "macan";
            turn = 1 // ganti pemain
            drawBoard();
            return;
          }
        }

        if (availableMoves.length > 0){
          const target = availableMoves[0];
          entities[target] = entities[index];
          delete entities[index];
          turn = turn === 1 ? 2 : 1;
          drawBoard();
        }
      }

      function moveUwong(index) {
        // Cek apakah uwong bisa dipindahkan ke titik yang dipilih dengan jarak satu garis
        const currentPosition = findUwongPosition();
        if (currentPosition !== -1) {
          const isValidMove = isValidMoveUwong(currentPosition, index);
          if (isValidMove) {
            entities[index] = "uwong";
            delete entities[currentPosition];
            uwongOnBoard++;
            turn = 2; // Beralih ke turn macan
          }
        }
      }

      function moveMacan(index) {
        // Cek apakah macan bisa dipindahkan ke titik yang dipilih dengan jarak satu koneksi
        const currentPosition = findMacanPosition();
        if (currentPosition !== -1) {
          const isValidMove = isValidMoveMacan(currentPosition, index);
          if (isValidMove) {
            entities[index] = "macan";
            delete entities[currentPosition];
            turn = 1; // Beralih ke turn uwong
          }
        }
      }

      // Fungsi untuk menemukan posisi uwong saat ini
      function findUwongPosition() {
        return Object.keys(entities).find(
          (index) => entities[index] === "uwong"
        );
      }

      // Fungsi untuk menemukan posisi macan saat ini
      function findMacanPosition() {
        return Object.keys(entities).find(
          (index) => entities[index] === "macan"
        );
      }

      // Validasi apakah gerakan uwong sah (jarak satu koneksi)
      function isValidMoveUwong(startIndex, endIndex) {
        const connection = connections.some(([a, b]) => {
          return (
            (a == startIndex && b == endIndex) ||
            (b == startIndex && a == endIndex)
          );
        });
        return connection;
      }

      // Validasi apakah gerakan macan sah (melompati uwong)
      function placeEntity(index) {
        if (uwongInHand === 21 && turn == 1) {
          placeUwongBlock(index);
          console.log(index);
        } else if (!(index in entities)) {
          if (macanInHand > 0 && turn == 2) {
            entities[index] = "macan";
            macanInHand--;
            turn = 1;
          } else if (uwongInHand > 0 && turn == 1) {
            entities[index] = "uwong";
            uwongInHand--;
            uwongOnBoard++;
            turn = 2;
          } else if (uwongInHand == 0 && turn == 1) {
            // Cek apakah ada uwong yang bisa dipindahkan
            moveUwong(index);
          } else if (macanInHand == 0 && turn == 2) {
            // Cek apakah macan bisa dipindahkan
            moveMacan(index);
          }
          drawBoard();
        }
      }

      function moveUwong(index) {
        const currentPosition = findUwongPosition();
        if (currentPosition !== -1) {
          const isValidMove = isValidMoveUwong(currentPosition, index);
          if (isValidMove) {
            entities[index] = "uwong";
            delete entities[currentPosition];
            uwongOnBoard++;
            turn = 2; // Beralih ke turn macan
          }
        }
      }

      function findUwongPosition() {
        return Object.keys(entities).find(
          (index) => entities[index] === "uwong"
        );
      }

      function findMacanPosition() {
        return Object.keys(entities).find(
          (index) => entities[index] === "macan"
        );
      }

      // Validasi apakah gerakan uwong sah (jarak satu koneksi)
      function isValidMoveUwong(startIndex, endIndex) {
        const connection = connections.some(([a, b]) => {
          return (
            (a == startIndex && b == endIndex) ||
            (b == startIndex && a == endIndex)
          );
        });
        return connection;
      }

      function moveMacan(index) {
        const currentPosition = findMacanPosition();
        if (currentPosition !== -1) {
          const isValidMove = isValidMoveMacan(currentPosition, index);
          if (isValidMove) {
            entities[index] = "macan";
            delete entities[currentPosition];
            turn = 1; // Beralih ke turn uwong
          }
        }
      }

      // Validasi apakah gerakan macan sah
      function isValidMoveMacan(startIndex, endIndex) {
        // Pastikan endIndex tidak sama dengan startIndex
        if (startIndex === endIndex) {
          return false; // Tidak boleh ke posisi yang sama
        }

        // 1. Cek apakah ada koneksi langsung antara startIndex dan endIndex
        const connection = connections.some(([a, b]) => {
          if (
            (a == startIndex && b == endIndex) ||
            (b == startIndex && a == endIndex)
          ) {
            // Pastikan titik tujuan kosong
            if (!(endIndex in entities)) {
              return true; // Gerakan sah
            }
          }
          return false;
        });

        if (connection) {
          return true; // Jika koneksi langsung ditemukan dan titik kosong, gerakan sah
        }

        // 2. Jika tidak ada koneksi langsung, coba cek apakah macan bisa melompati uwong
        // Cek apakah ada uwong di tengah antara startIndex dan endIndex
        const midpoint = Math.floor(
          (parseInt(startIndex) + parseInt(endIndex)) / 2
        );
        if (entities[midpoint] === "uwong" && !(endIndex in entities)) {
          // Pastikan hanya bisa melompati uwong yang ada di jalur yang valid
          const isAdjacent = connections.some(([a, b]) => {
            return (
              (a == startIndex && b == midpoint) ||
              (a == midpoint && b == endIndex)
            );
          });
          if (isAdjacent) {
            return true; // Gerakan sah jika ada uwong di tengah dan titik tujuan kosong, serta ada koneksi yang valid
          }
        }

        return false; // Jika tidak ada koneksi dan tidak ada uwong untuk dilompati, gerakan tidak sah
      }

      function placeUwongBlock(index) {
        const row = Math.floor(index / 5);
        const col = index % 5;
        let canPlace = true;
        if (
          (index >= 0 && index < 3) ||
          (index >= 5 && index < 8) ||
          (index >= 10 && index < 13)
        ) {
          canPlace = true;
        } else canPlace = false;
        if (canPlace) {
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const newIndex = (row + i) * 5 + (col + j);
              entities[newIndex] = "uwong";
              uwongInHand--;
              uwongOnBoard++;
            }
          }
          drawBoard();
          turn = 2; // Switch turn to macan
        }
      }

      canvas.addEventListener("click", (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        let closestIndex = -1;
        let minDist = 20;
        points.forEach((point, index) => {
          const dist = Math.hypot(point.x - x, point.y - y);
          if (dist < minDist) {
            minDist = dist;
            closestIndex = index;
          }
        });

        if (closestIndex !== -1) {
          placeEntity(closestIndex);
        }
      });

      drawBoard();
    </script>
  </body>
</html>